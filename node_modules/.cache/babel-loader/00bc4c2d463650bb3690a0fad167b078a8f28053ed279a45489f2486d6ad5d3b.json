{"ast":null,"code":"import{useState,useEffect,useRef}from'react';/**\r\n * A custom React hook that tells you when an element is visible on the screen.\r\n * @param {Object} options - Intersection Observer options (e.g., threshold, rootMargin).\r\n * @returns {[React.RefObject, boolean]} - A ref to attach to the element and a boolean indicating if it's visible.\r\n */export default function useOnScreen(options){const ref=useRef(null);const[isVisible,setIsVisible]=useState(false);useEffect(()=>{const observer=new IntersectionObserver(_ref=>{let[entry]=_ref;// If the element is intersecting (visible)\nif(entry.isIntersecting){setIsVisible(true);// Stop observing the element once it has become visible to prevent re-triggering\nobserver.unobserve(entry.target);}},options);if(ref.current){observer.observe(ref.current);}// Cleanup function to unobserve the element when the component unmounts\nreturn()=>{if(ref.current){// eslint-disable-next-line react-hooks/exhaustive-deps\nobserver.unobserve(ref.current);}};},[ref,options]);// Re-run effect if ref or options change\nreturn[ref,isVisible];}","map":{"version":3,"names":["useState","useEffect","useRef","useOnScreen","options","ref","isVisible","setIsVisible","observer","IntersectionObserver","_ref","entry","isIntersecting","unobserve","target","current","observe"],"sources":["D:/CollegeWeb/collegexplorer-app/src/hooks/useOnScreen.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\r\n\r\n/**\r\n * A custom React hook that tells you when an element is visible on the screen.\r\n * @param {Object} options - Intersection Observer options (e.g., threshold, rootMargin).\r\n * @returns {[React.RefObject, boolean]} - A ref to attach to the element and a boolean indicating if it's visible.\r\n */\r\nexport default function useOnScreen(options) {\r\n  const ref = useRef(null);\r\n  const [isVisible, setIsVisible] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const observer = new IntersectionObserver(([entry]) => {\r\n      // If the element is intersecting (visible)\r\n      if (entry.isIntersecting) {\r\n        setIsVisible(true);\r\n        // Stop observing the element once it has become visible to prevent re-triggering\r\n        observer.unobserve(entry.target);\r\n      }\r\n    }, options);\r\n\r\n    if (ref.current) {\r\n      observer.observe(ref.current);\r\n    }\r\n\r\n    // Cleanup function to unobserve the element when the component unmounts\r\n    return () => {\r\n      if (ref.current) {\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n        observer.unobserve(ref.current);\r\n      }\r\n    };\r\n  }, [ref, options]); // Re-run effect if ref or options change\r\n\r\n  return [ref, isVisible];\r\n}"],"mappings":"AAAA,OAASA,QAAQ,CAAEC,SAAS,CAAEC,MAAM,KAAQ,OAAO,CAEnD;AACA;AACA;AACA;AACA,GACA,cAAe,SAAS,CAAAC,WAAWA,CAACC,OAAO,CAAE,CAC3C,KAAM,CAAAC,GAAG,CAAGH,MAAM,CAAC,IAAI,CAAC,CACxB,KAAM,CAACI,SAAS,CAAEC,YAAY,CAAC,CAAGP,QAAQ,CAAC,KAAK,CAAC,CAEjDC,SAAS,CAAC,IAAM,CACd,KAAM,CAAAO,QAAQ,CAAG,GAAI,CAAAC,oBAAoB,CAACC,IAAA,EAAa,IAAZ,CAACC,KAAK,CAAC,CAAAD,IAAA,CAChD;AACA,GAAIC,KAAK,CAACC,cAAc,CAAE,CACxBL,YAAY,CAAC,IAAI,CAAC,CAClB;AACAC,QAAQ,CAACK,SAAS,CAACF,KAAK,CAACG,MAAM,CAAC,CAClC,CACF,CAAC,CAAEV,OAAO,CAAC,CAEX,GAAIC,GAAG,CAACU,OAAO,CAAE,CACfP,QAAQ,CAACQ,OAAO,CAACX,GAAG,CAACU,OAAO,CAAC,CAC/B,CAEA;AACA,MAAO,IAAM,CACX,GAAIV,GAAG,CAACU,OAAO,CAAE,CACf;AACAP,QAAQ,CAACK,SAAS,CAACR,GAAG,CAACU,OAAO,CAAC,CACjC,CACF,CAAC,CACH,CAAC,CAAE,CAACV,GAAG,CAAED,OAAO,CAAC,CAAC,CAAE;AAEpB,MAAO,CAACC,GAAG,CAAEC,SAAS,CAAC,CACzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}